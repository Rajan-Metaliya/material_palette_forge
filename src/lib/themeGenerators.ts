import type { ThemeConfiguration, MaterialColors, ThemeGradient } from '@/types/theme';

function toFlutterColor(hex: string): string {
  return `Color(0xFF${hex.substring(1).toUpperCase()})`;
}

const formatKeyForDisplay = (key: string) => {
  return key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
}

export function generateFlutterCode(theme: ThemeConfiguration): string {
  const colors = theme.colors;
  const fonts = theme.fonts;
  // Properties are not directly mapped in this simplified Flutter theme, but could be used for custom widgets.

  let colorSchemeEntries = '';
  for (const key in colors) {
    if (Object.prototype.hasOwnProperty.call(colors, key)) {
      const colorKey = key as keyof MaterialColors;
      // Skip seedColor for manual definition
      if (colorKey === 'primary') { // Use primary as seed for fromSeed, then override
         colorSchemeEntries += `    seedColor: ${toFlutterColor(colors[colorKey])},\n`;
      }
      colorSchemeEntries += `    ${colorKey}: ${toFlutterColor(colors[colorKey])},\n`;
    }
  }

  return `// lib/theme/app_theme.dart
import 'package:flutter/material.dart';

// Generated by Material Palette Forge
// Font families:
// Primary: ${fonts.primary}
// Secondary: ${fonts.secondary}
// Monospace: ${fonts.monospace}

// Theme Properties (for reference or custom widgets):
// Spacing:
${Object.entries(theme.properties.spacing).map(([key, value]) => `//   ${formatKeyForDisplay(key)}: ${value}`).join('\n')}
// Border Radius:
${Object.entries(theme.properties.borderRadius).map(([key, value]) => `//   ${formatKeyForDisplay(key)}: ${value}`).join('\n')}
// Border Width:
${Object.entries(theme.properties.borderWidth).map(([key, value]) => `//   ${formatKeyForDisplay(key)}: ${value}`).join('\n')}
// Opacity:
${Object.entries(theme.properties.opacity).map(([key, value]) => `//   ${formatKeyForDisplay(key)}: ${value}`).join('\n')}
// Elevation:
${Object.entries(theme.properties.elevation).map(([key, value]) => `//   ${formatKeyForDisplay(key)}: ${value}`).join('\n')}
// Gradients:
${theme.properties.gradients.map((g, i) => `//   Gradient ${i + 1} (${g.name}): ${g.type}, ${g.direction || ''}, [${g.colors.join(', ')}]`).join('\n')}


class AppTheme {
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
${colorSchemeEntries.trimEnd()}
      ),
      textTheme: TextTheme(
        // Example mapping, adjust as needed for your app's typography scale
        displayLarge: TextStyle(fontFamily: '${fonts.primary}'),
        displayMedium: TextStyle(fontFamily: '${fonts.primary}'),
        displaySmall: TextStyle(fontFamily: '${fonts.primary}'),
        headlineLarge: TextStyle(fontFamily: '${fonts.primary}'),
        headlineMedium: TextStyle(fontFamily: '${fonts.primary}'),
        headlineSmall: TextStyle(fontFamily: '${fonts.primary}'),
        titleLarge: TextStyle(fontFamily: '${fonts.primary}'),
        titleMedium: TextStyle(fontFamily: '${fonts.secondary}'),
        titleSmall: TextStyle(fontFamily: '${fonts.secondary}'),
        bodyLarge: TextStyle(fontFamily: '${fonts.secondary}'),
        bodyMedium: TextStyle(fontFamily: '${fonts.secondary}'),
        bodySmall: TextStyle(fontFamily: '${fonts.secondary}'),
        labelLarge: TextStyle(fontFamily: '${fonts.secondary}'),
        labelMedium: TextStyle(fontFamily: '${fonts.secondary}'),
        labelSmall: TextStyle(fontFamily: '${fonts.secondary}'),
      ),
      // Example of applying a default border radius (using properties.borderRadius.md)
      // cardTheme: CardTheme(
      //   shape: RoundedRectangleBorder(
      //     borderRadius: BorderRadius.circular(${parseFloat(theme.properties.borderRadius.md)}),
      //   ),
      //   elevation: ${parseFloat(theme.properties.elevation.level1.split(' ')[0]) || 1}, // Approx
      // ),
      // buttonTheme: ButtonThemeData(
      //   shape: RoundedRectangleBorder(
      //     borderRadius: BorderRadius.circular(${parseFloat(theme.properties.borderRadius.sm)}),
      //   ),
      // ),
    );
  }

  // Optional: Define a darkTheme similarly if needed
  // static ThemeData get darkTheme { ... }
}
`;
}

export function generateJson(theme: ThemeConfiguration): string {
  // Convert theme object to the specified JSON structure
  const outputJson = {
    colors: {
      primary: theme.colors.primary,
      secondary: theme.colors.secondary,
      tertiary: theme.colors.tertiary,
      error: theme.colors.error,
      extended: {
        surface: theme.colors.surface,
        onSurface: theme.colors.onSurface,
        primaryContainer: theme.colors.primaryContainer,
        onPrimaryContainer: theme.colors.onPrimaryContainer,
        secondaryContainer: theme.colors.secondaryContainer,
        onSecondaryContainer: theme.colors.onSecondaryContainer,
        tertiaryContainer: theme.colors.tertiaryContainer,
        onTertiaryContainer: theme.colors.onTertiaryContainer,
        errorContainer: theme.colors.errorContainer,
        onErrorContainer: theme.colors.onErrorContainer,
        surfaceVariant: theme.colors.surfaceVariant,
        onSurfaceVariant: theme.colors.onSurfaceVariant,
        outline: theme.colors.outline,
        outlineVariant: theme.colors.outlineVariant,
        shadow: theme.colors.shadow,
        scrim: theme.colors.scrim,
        inverseSurface: theme.colors.inverseSurface,
        onInverseSurface: theme.colors.onInverseSurface,
        inversePrimary: theme.colors.inversePrimary,
      }
    },
    fonts: {
      primary: theme.fonts.primary,
      secondary: theme.fonts.secondary,
      extended: { // Example of extended, maps to monospace for simplicity
        monospace: theme.fonts.monospace,
      }
    },
    properties: theme.properties
  };
  return JSON.stringify(outputJson, null, 2);
}

export function generateFigmaTokens(theme: ThemeConfiguration): string {
  const figmaTokens: any = {
    color: {},
    fontFamily: {},
    spacing: {},
    borderRadius: {},
    borderWidth: {},
    opacity: {},
    boxShadow: {}, // For elevation
    gradient: {},
  };

  // Colors
  for (const key in theme.colors) {
    if (Object.prototype.hasOwnProperty.call(theme.colors, key)) {
      figmaTokens.color[key] = { value: theme.colors[key as keyof MaterialColors], type: "color" };
    }
  }

  // Fonts
  figmaTokens.fontFamily.primary = { value: theme.fonts.primary, type: "fontFamily" };
  figmaTokens.fontFamily.secondary = { value: theme.fonts.secondary, type: "fontFamily" };
  figmaTokens.fontFamily.monospace = { value: theme.fonts.monospace, type: "fontFamily" };
  
  // Spacing
  for (const key in theme.properties.spacing) {
    figmaTokens.spacing[key] = { value: theme.properties.spacing[key as keyof typeof theme.properties.spacing], type: "spacing" };
  }

  // Border Radius
  for (const key in theme.properties.borderRadius) {
    figmaTokens.borderRadius[key] = { value: theme.properties.borderRadius[key as keyof typeof theme.properties.borderRadius], type: "borderRadius" };
  }
  
  // Border Width
  for (const key in theme.properties.borderWidth) {
    figmaTokens.borderWidth[key] = { value: theme.properties.borderWidth[key as keyof typeof theme.properties.borderWidth], type: "borderWidth" }; // Or "dimension"
  }
  
  // Opacity
  for (const key in theme.properties.opacity) {
    figmaTokens.opacity[key] = { value: theme.properties.opacity[key as keyof typeof theme.properties.opacity].toString(), type: "opacity" }; // string for figma tokens
  }
  
  // Elevation (as boxShadow)
  for (const key in theme.properties.elevation) {
    const levelKey = key.replace('level', '');
    figmaTokens.boxShadow[levelKey] = { value: theme.properties.elevation[key as keyof typeof theme.properties.elevation], type: "boxShadow" };
  }

  // Gradients
  theme.properties.gradients.forEach((gradient: ThemeGradient, index: number) => {
    // Figma gradient syntax can be complex. This is a simplified linear gradient representation.
    // Example: "linear-gradient(to right, #ff0000, #00ff00)"
    const colorsString = gradient.colors.join(', ');
    let figmaGradientValue = '';
    if (gradient.type === 'linear') {
        figmaGradientValue = `linear-gradient(${gradient.direction || 'to right'}, ${colorsString})`;
    } else if (gradient.type === 'radial') {
        // Basic radial gradient, more properties might be needed for full control
        figmaGradientValue = `radial-gradient(${gradient.shape || 'circle'} ${gradient.extent || 'farthest-corner'}, ${colorsString})`;
    }
    
    figmaTokens.gradient[gradient.name.replace(/\s+/g, '-').toLowerCase() || `gradient-${index + 1}`] = {
      value: figmaGradientValue,
      type: "gradient" // Custom type or rely on string interpretation
    };
  });


  return JSON.stringify(figmaTokens, null, 2);
}
